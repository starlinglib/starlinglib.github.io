<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><!-- saved from url=(0014)about:internet --><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" href="../../style.css" type="text/css" media="screen"><link rel="stylesheet" href="../../print.css" type="text/css" media="print"><link rel="stylesheet" href="../../override.css" type="text/css"><meta name="keywords" content="RenderSupport,starling.core.RenderSupport,VERSION,antiAliasing,backBufferHeight,backBufferWidth,blendMode,contentScaleFactor,context,contextData,current,drawCount,enableErrorChecking,handleLostContext,isStarted,juggler,modelViewMatrix,multitouchEnabled,mvpMatrix,mvpMatrix3D,nativeOverlay,nativeStage,profile,projectionMatrix,renderTarget,root,scissorRectangle,shareContext,showStats,simulateMultitouch,stage,stage3D,viewPort,advanceTime,applyBlendMode,assembleAgal,batchQuad,clear,clear,configureBackBuffer,deleteProgram,dispose,dispose,finishQuadBatch,getProgram,hasProgram,loadIdentity,makeCurrent,nextFrame,nextFrame,popMatrix,prependMatrix,pushMatrix,raiseDrawCount,registerProgram,render,resetMatrix,rotateMatrix,scaleMatrix,setBlendFactors,setDefaultBlendFactors,setOrthographicProjection,showStatsAt,start,stop,transformMatrix,transformMatrixForObject,translateMatrix"><title>starling.core.RenderSupport</title></head><body><script language="javascript" type="text/javascript" src="../../asdoc.js"></script><script language="javascript" type="text/javascript" src="../../help.js"></script><script language="javascript" type="text/javascript" src="../../cookies.js"></script><script language="javascript" type="text/javascript"><!--
				asdocTitle = 'RenderSupport - Starling API 1.3 | Starling中文站';
				var baseRef = '../../';
				window.onload = configPage;
			--></script>
<script type="text/javascript">
			scrollToNameAnchor();
		</script><table class="titleTable" cellpadding="0" cellspacing="0" id="titleTable" style="display:none"><tr><td class="titleTableTitle" align="left">Starling API 1.3 | Starling中文站</td><td class="titleTableTopNav" align="right"><a href="../../package-summary.html" onclick="loadClassListFrame('../../all-classes.html')">All Packages</a>&nbsp;|&nbsp;<a href="../../class-summary.html" onclick="loadClassListFrame('../../all-classes.html')">All Classes</a>&nbsp;|&nbsp;<a href="../../all-index-A.html" onclick="loadClassListFrame('../../index-list.html')">Index</a>&nbsp;|&nbsp;<a id="framesLink1" href="../../index.html?starling/core/RenderSupport.html&amp;starling/core/class-list.html">Frames</a><a id="noFramesLink1" style="display:none" href="" onclick="parent.location=document.location"> No Frames </a></td><td class="titleTableLogo" align="right" rowspan="3"><img src="../../images/logo.jpg" class="logoImage" alt=" Adobe Logo " title=" Adobe Logo "></td></tr><tr class="titleTableRow2"><td class="titleTableSubTitle" id="subTitle" align="left">RenderSupport</td><td class="titleTableSubNav" id="subNav" align="right"><a href="#propertySummary">Properties</a>&nbsp;| <a href="#methodSummary">Methods</a></td></tr><tr class="titleTableRow3"><td colspan="3">&nbsp;</td></tr></table><script language="javascript" type="text/javascript" xml:space="preserve">
				<!--
				
					if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle("RenderSupport"); titleBar_setSubNav(false,true,false,false,false,false,false,false,true,false,false	,false,false,false,false,false);}	
				-->
			</script><div xmlns:fn="http://www.w3.org/2005/xpath-functions" class="MainContent"><table class="classHeaderTable" cellpadding="0" cellspacing="0"><tr><td class="classHeaderTableLabel">Package</td><td><a href="package-detail.html" onclick="javascript:loadClassListFrame('class-list.html')">starling.core</a></td></tr><tr><td class="classHeaderTableLabel">Class</td><td class="classSignature">public  class  RenderSupport</td></tr><tr><td class="classHeaderTableLabel">Inheritance</td><td class="inheritanceList">RenderSupport  <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> Object</td></tr></table><p></p><p></p><p></p> 这个类 包含了简化Stage3D渲染的辅助方法.
	  RenderSupport实例可以被任意显示对象的“渲染”方法使用. 
	  它可以对当前变换矩阵和其它帮助方法进行处理 (与OpenGL 1.x的变换矩阵方法类似).
	 <p></p><br/><hr></div><a name="propertySummary"></a><div class="summarySection"><div class="summaryTableTitle">Public Properties</div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableProperty"><tr><th>&nbsp;</th><th colspan="2">Property</th><th class="summaryTableOwnerCol">Defined By</th></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#backBufferHeight" class="signatureLink">backBufferHeight</a> : int<div class="summaryTableDescription"> 后台缓冲区的高度，它是被最后一次调用'RenderSupport.configureBackBuffer()'时确定的。
		 请注意：更改此值实际上并不会修改后台缓冲区的尺寸；setter方法只是用来通知Starling后台缓冲区的尺寸（它无法控制的情况，比如共享上下文的情况下）。
		 </div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#backBufferWidth" class="signatureLink">backBufferWidth</a> : int<div class="summaryTableDescription"> 后台缓冲区的宽度，它是被最后一次调用'RenderSupport.configureBackBuffer()'时确定的。
		 请注意：更改此值实际上并不会修改后台缓冲区的尺寸；setter方法只是用来通知Starling后台缓冲区的尺寸（它无法控制的情况，比如共享上下文的情况下）。
         </div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#blendMode" class="signatureLink">blendMode</a> : String<div class="summaryTableDescription">
		 在渲染中将要使用的混合模式.要应用这个设置，你必须手工调用"applyBlendMode"方法(因为实际的混合因素依赖于对PMA模式)。
		 </div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#drawCount" class="signatureLink">drawCount</a> : int<div class="summaryTableDescription">[read-only]  指出stage3D绘制调用次数.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#modelViewMatrix" class="signatureLink">modelViewMatrix</a> : Matrix<div class="summaryTableDescription">[read-only]  返回当前模型视图矩阵.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#mvpMatrix" class="signatureLink">mvpMatrix</a> : Matrix<div class="summaryTableDescription">[read-only]  计算模型视图矩阵和映射矩阵的商.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#mvpMatrix3D" class="signatureLink">mvpMatrix3D</a> : Matrix3D<div class="summaryTableDescription">[read-only]  计算模型视图矩阵和映射矩阵的商保存到一个三维矩阵中.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#projectionMatrix" class="signatureLink">projectionMatrix</a> : Matrix<div class="summaryTableDescription">[read-only]  返回当前映射矩阵.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#renderTarget" class="signatureLink">renderTarget</a> : <a href="../../starling/textures/Texture.html">Texture</a><div class="summaryTableDescription">当前即将被渲染的纹理，如果是'null'将渲染到后台缓冲区。如果你设置一个新对象，则它马上就会被启动。</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#scissorRectangle" class="signatureLink">scissorRectangle</a> : Rectangle<div class="summaryTableDescription"> 裁切矩形可以被用于限制当前渲染目标到一个指定的区域。
		 这个方法需要stage坐标系中的一个矩形(和Context3D的同名方法不同，它使用的是像素)。传递null将关闭裁剪。注意：这不是一个副本，小心使用！</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr></table></div><a name="methodSummary"></a><div class="summarySection"><div class="summaryTableTitle">Public Methods </div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableMethod"><tr><th>&nbsp;</th><th colspan="2">Method</th><th class="summaryTableOwnerCol">Defined By</th></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#RenderSupport()" class="signatureLink">RenderSupport</a>()</div><div class="summaryTableDescription"> 创建一个携带空矩阵堆的RenderSupport对象.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#applyBlendMode()" class="signatureLink">applyBlendMode</a>(premultipliedAlpha:Boolean):void</div><div class="summaryTableDescription"> 在当前的渲染内容中使用合适的混合因数.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#assembleAgal()" class="signatureLink">assembleAgal</a>(vertexShader:String, fragmentShader:String, resultProgram:Program3D = null):Program3D</div><div class="summaryTableDescription">[static] 
		 汇编通过字符串传递的片段和顶点着色器到Program3D中。如果你传递了一个'resultProgram'参数，那么结果就会上传到传入的这个Program3D对象中。
		 否则，将从当前的Stage3D上下文中，创建一个新的Program3D对象。
		 </div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#batchQuad()" class="signatureLink">batchQuad</a>(quad:<a href="../../starling/display/Quad.html">Quad</a>, parentAlpha:Number, texture:<a href="../../starling/textures/Texture.html">Texture</a> = null, smoothing:String = null):void</div><div class="summaryTableDescription"> 在当前未渲染的四角面组中添加一个四角面.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#clear()" class="signatureLink">clear</a>(rgb:uint = 0, alpha:Number = 0.0):void</div><div class="summaryTableDescription"> 以特定颜色和透明度清除渲染内容.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#clear()" class="signatureLink">clear</a>(rgb:uint = 0, alpha:Number = 0.0):void</div><div class="summaryTableDescription">[static]  以特定颜色和透明度清除渲染内容.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#configureBackBuffer()" class="signatureLink">configureBackBuffer</a>(width:int, height:int, antiAlias:int, enableDepthAndStencil:Boolean):void</div><div class="summaryTableDescription">
		 配置当前Context3D对象的后台缓冲区。
		 通过使用这个方法，Starling可以存储后台缓冲区的大小，并且在其它方法(比如矩形区域的裁切)中使用这个信息。
		 后台缓冲区的宽度和高度，可以在以后通过相同的属性名称来访问。
		 </div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#dispose()" class="signatureLink">dispose</a>():void</div><div class="summaryTableDescription"> 删除所四角面.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#finishQuadBatch()" class="signatureLink">finishQuadBatch</a>():void</div><div class="summaryTableDescription"> 渲染当前四角面组然后重置.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#loadIdentity()" class="signatureLink">loadIdentity</a>():void</div><div class="summaryTableDescription"> 把模型视图矩阵变换为单位矩阵.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#nextFrame()" class="signatureLink">nextFrame</a>():void</div><div class="summaryTableDescription"> 重置矩阵和混合模式堆，四角面组索引,和绘画计数。</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#popMatrix()" class="signatureLink">popMatrix</a>():void</div><div class="summaryTableDescription"> 访问保存在堆中的模型视图矩阵.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#prependMatrix()" class="signatureLink">prependMatrix</a>(matrix:Matrix):void</div><div class="summaryTableDescription"> 与另一矩阵相乘得到模型视图矩阵.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#pushMatrix()" class="signatureLink">pushMatrix</a>():void</div><div class="summaryTableDescription"> 把当前模型视图矩阵推入堆中以便随后访问.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#raiseDrawCount()" class="signatureLink">raiseDrawCount</a>(value:uint = 1):void</div><div class="summaryTableDescription"> 提升绘制计数特定的数值.在调用自定义渲染方法时调用这个方法来保持渲染数据的同步 </div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#resetMatrix()" class="signatureLink">resetMatrix</a>():void</div><div class="summaryTableDescription"> 置空矩阵堆, 把模型视图矩阵重设为单位矩阵.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#rotateMatrix()" class="signatureLink">rotateMatrix</a>(angle:Number):void</div><div class="summaryTableDescription"> 根据相应旋转变化得到模型视图矩阵.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#scaleMatrix()" class="signatureLink">scaleMatrix</a>(sx:Number, sy:Number):void</div><div class="summaryTableDescription"> 根据相应缩放变化得到模型视图矩阵.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#setBlendFactors()" class="signatureLink">setBlendFactors</a>(premultipliedAlpha:Boolean, blendMode:String = normal):void</div><div class="summaryTableDescription">[static]  设置相应混合模式的混合参数.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#setDefaultBlendFactors()" class="signatureLink">setDefaultBlendFactors</a>(premultipliedAlpha:Boolean):void</div><div class="summaryTableDescription">[static]  不再使用。调用'setBlendFactors'方法.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#setOrthographicProjection()" class="signatureLink">setOrthographicProjection</a>(x:Number, y:Number, width:Number, height:Number):void</div><div class="summaryTableDescription"> 设置正面二维渲染的矩阵映射.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#transformMatrix()" class="signatureLink">transformMatrix</a>(object:<a href="../../starling/display/DisplayObject.html">DisplayObject</a>):void</div><div class="summaryTableDescription"> 根据对象的坐标变换，缩放和旋转生成模型视图矩阵.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#transformMatrixForObject()" class="signatureLink">transformMatrixForObject</a>(matrix:Matrix, object:<a href="../../starling/display/DisplayObject.html">DisplayObject</a>):void</div><div class="summaryTableDescription">[static]  把一个对象的位移，缩放和旋转转化为自定义矩阵.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#translateMatrix()" class="signatureLink">translateMatrix</a>(dx:Number, dy:Number):void</div><div class="summaryTableDescription"> 根据相应位移变化得到模型视图矩阵.</div></td><td class="summaryTableOwnerCol">RenderSupport</td></tr></table></div><script language="javascript" type="text/javascript"><!--
										showHideInherited();
										--></script><div class="MainContent"><div class="detailSectionHeader">Property Detail</div><a name="propertyDetail"></a><a name="backBufferHeight"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">backBufferHeight</td><td class="detailHeaderType">property</td></tr></table><div class="detailBody"><code>backBufferHeight:int</code><p></p><p></p><p> 后台缓冲区的高度，它是被最后一次调用'RenderSupport.configureBackBuffer()'时确定的。
		 请注意：更改此值实际上并不会修改后台缓冲区的尺寸；setter方法只是用来通知Starling后台缓冲区的尺寸（它无法控制的情况，比如共享上下文的情况下）。
		 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get backBufferHeight():int</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set backBufferHeight(value:int):void</code><br/></div><a name="propertyDetail"></a><a name="backBufferWidth"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">backBufferWidth</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>backBufferWidth:int</code><p></p><p></p><p> 后台缓冲区的宽度，它是被最后一次调用'RenderSupport.configureBackBuffer()'时确定的。
		 请注意：更改此值实际上并不会修改后台缓冲区的尺寸；setter方法只是用来通知Starling后台缓冲区的尺寸（它无法控制的情况，比如共享上下文的情况下）。
         </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get backBufferWidth():int</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set backBufferWidth(value:int):void</code><br/></div><a name="propertyDetail"></a><a name="blendMode"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">blendMode</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>blendMode:String</code><p></p><p></p><p>
		 在渲染中将要使用的混合模式.要应用这个设置，你必须手工调用"applyBlendMode"方法(因为实际的混合因素依赖于对PMA模式)。
		 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get blendMode():String</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set blendMode(value:String):void</code><br/></div><a name="propertyDetail"></a><a name="drawCount"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">drawCount</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>drawCount:int</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p> 指出stage3D绘制调用次数. </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get drawCount():int</code><br/></div><a name="propertyDetail"></a><a name="modelViewMatrix"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">modelViewMatrix</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>modelViewMatrix:Matrix</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p> 返回当前模型视图矩阵. 注意：不是拷贝 - 小心使用! </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get modelViewMatrix():Matrix</code><br/></div><a name="propertyDetail"></a><a name="mvpMatrix"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">mvpMatrix</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>mvpMatrix:Matrix</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p> 计算模型视图矩阵和映射矩阵的商. 
		  注意：不要保存这个对象的引用！每次调用实际返回的是同一实例。 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get mvpMatrix():Matrix</code><br/></div><a name="propertyDetail"></a><a name="mvpMatrix3D"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">mvpMatrix3D</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>mvpMatrix3D:Matrix3D</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p> 计算模型视图矩阵和映射矩阵的商保存到一个三维矩阵中. 
		  注意：不要保存这个对象的引用！每次调用实际返回的是同一实例。 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get mvpMatrix3D():Matrix3D</code><br/></div><a name="propertyDetail"></a><a name="projectionMatrix"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">projectionMatrix</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>projectionMatrix:Matrix</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p> 返回当前映射矩阵. 注意：不是拷贝 - 小心使用! </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get projectionMatrix():Matrix</code><br/></div><a name="propertyDetail"></a><a name="renderTarget"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">renderTarget</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>renderTarget:<a href="../../starling/textures/Texture.html">Texture</a></code><p></p><p></p><p>当前即将被渲染的纹理，如果是'null'将渲染到后台缓冲区。如果你设置一个新对象，则它马上就会被启动。</p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get renderTarget():<a href="../../starling/textures/Texture.html">Texture</a></code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set renderTarget(value:<a href="../../starling/textures/Texture.html">Texture</a>):void</code><br/></div><a name="propertyDetail"></a><a name="scissorRectangle"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">scissorRectangle</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>scissorRectangle:Rectangle</code><p></p><p></p><p> 裁切矩形可以被用于限制当前渲染目标到一个指定的区域。
		 这个方法需要stage坐标系中的一个矩形(和Context3D的同名方法不同，它使用的是像素)。传递null将关闭裁剪。注意：这不是一个副本，小心使用！</p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get scissorRectangle():Rectangle</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set scissorRectangle(value:Rectangle):void</code><br/></div><a name="constructorDetail"></a><div class="detailSectionHeader">Constructor Detail</div><a name="RenderSupport()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">RenderSupport</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Constructor</td></tr></table><div class="detailBody"><code>public function RenderSupport()</code><p></p><p> 创建一个携带空矩阵堆的RenderSupport对象. </p></div><a name="methodDetail"></a><div class="detailSectionHeader">Method Detail</div><a name="applyBlendMode()"></a><a name="applyBlendMode(Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">applyBlendMode</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td></tr></table><div class="detailBody"><code> public function applyBlendMode(premultipliedAlpha:Boolean):void</code><p></p><p></p><p> 在当前的渲染内容中使用合适的混合因数. </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">premultipliedAlpha</span>:Boolean</code></td></tr></table></p></div><a name="assembleAgal()"></a><a name="assembleAgal(String,String,flash.display3D.Program3D)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">assembleAgal</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public static function assembleAgal(vertexShader:String, fragmentShader:String, resultProgram:Program3D = null):Program3D</code><p></p><p></p><p>
		 汇编通过字符串传递的片段和顶点着色器到Program3D中。如果你传递了一个'resultProgram'参数，那么结果就会上传到传入的这个Program3D对象中。
		 否则，将从当前的Stage3D上下文中，创建一个新的Program3D对象。
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">vertexShader</span>:String</code> &mdash; 顶点着色器源码
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fragmentShader</span>:String</code> &mdash; 片段着色器源码
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">resultProgram</span>:Program3D</code> (default = <code>null</code>)<code></code> &mdash; Program3D对象
		 </td></tr></table></p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>Program3D</code> &mdash; Program3D对象
		 </td></tr></table></div><a name="batchQuad()"></a><a name="batchQuad(starling.display.Quad,Number,starling.textures.Texture,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">batchQuad</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function batchQuad(quad:<a href="../../starling/display/Quad.html">Quad</a>, parentAlpha:Number, texture:<a href="../../starling/textures/Texture.html">Texture</a> = null, smoothing:String = null):void</code><p></p><p></p><p> 在当前未渲染的四角面组中添加一个四角面. 如果当前状态改变则立即渲染之前组中四角面,然后重置当前组。 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">quad</span>:<a href="../../starling/display/Quad.html">Quad</a></code></td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">parentAlpha</span>:Number</code></td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">texture</span>:<a href="../../starling/textures/Texture.html">Texture</a></code> (default = <code>null</code>)<code></code></td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">smoothing</span>:String</code> (default = <code>null</code>)<code></code></td></tr></table></p></div><a name="clear()"></a><a name="clear(uint,Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">clear</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function clear(rgb:uint = 0, alpha:Number = 0.0):void</code><p></p><p></p><p> 以特定颜色和透明度清除渲染内容. 
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rgb</span>:uint</code> (default = <code>0</code>)<code></code> &mdash; RGB色值
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alpha</span>:Number</code> (default = <code>0.0</code>)<code></code> &mdash; 透明度
		 </td></tr></table></p></div><a name="clear()"></a><a name="clear(uint,Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">clear</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public static function clear(rgb:uint = 0, alpha:Number = 0.0):void</code><p></p><p></p><p> 以特定颜色和透明度清除渲染内容. 
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rgb</span>:uint</code> (default = <code>0</code>)<code></code> &mdash; RGB色值
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alpha</span>:Number</code> (default = <code>0.0</code>)<code></code> &mdash; 透明度
		 </td></tr></table></p></div><a name="configureBackBuffer()"></a><a name="configureBackBuffer(int,int,int,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">configureBackBuffer</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function configureBackBuffer(width:int, height:int, antiAlias:int, enableDepthAndStencil:Boolean):void</code><p></p><p></p><p>
		 配置当前Context3D对象的后台缓冲区。
		 通过使用这个方法，Starling可以存储后台缓冲区的大小，并且在其它方法(比如矩形区域的裁切)中使用这个信息。
		 后台缓冲区的宽度和高度，可以在以后通过相同的属性名称来访问。
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:int</code> &mdash; 宽度
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:int</code> &mdash; 高度
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">antiAlias</span>:int</code> &mdash; 抗锯齿级别
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">enableDepthAndStencil</span>:Boolean</code> &mdash; 是否开启深度和印模缓冲区
		 </td></tr></table></p></div><a name="dispose()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">dispose</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function dispose():void</code><p></p><p></p><p> 删除所四角面. </p></div><a name="finishQuadBatch()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">finishQuadBatch</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function finishQuadBatch():void</code><p></p><p></p><p> 渲染当前四角面组然后重置. </p></div><a name="loadIdentity()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">loadIdentity</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function loadIdentity():void</code><p></p><p></p><p> 把模型视图矩阵变换为单位矩阵. </p></div><a name="nextFrame()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">nextFrame</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function nextFrame():void</code><p></p><p></p><p> 重置矩阵和混合模式堆，四角面组索引,和绘画计数。</p></div><a name="popMatrix()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">popMatrix</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function popMatrix():void</code><p></p><p></p><p> 访问保存在堆中的模型视图矩阵. </p></div><a name="prependMatrix()"></a><a name="prependMatrix(flash.geom.Matrix)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">prependMatrix</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function prependMatrix(matrix:Matrix):void</code><p></p><p></p><p> 与另一矩阵相乘得到模型视图矩阵. </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">matrix</span>:Matrix</code></td></tr></table></p></div><a name="pushMatrix()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">pushMatrix</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function pushMatrix():void</code><p></p><p></p><p> 把当前模型视图矩阵推入堆中以便随后访问. </p></div><a name="raiseDrawCount()"></a><a name="raiseDrawCount(uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">raiseDrawCount</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function raiseDrawCount(value:uint = 1):void</code><p></p><p></p><p> 提升绘制计数特定的数值.在调用自定义渲染方法时调用这个方法来保持渲染数据的同步 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:uint</code> (default = <code>1</code>)<code></code></td></tr></table></p></div><a name="resetMatrix()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">resetMatrix</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function resetMatrix():void</code><p></p><p></p><p> 置空矩阵堆, 把模型视图矩阵重设为单位矩阵. </p></div><a name="rotateMatrix()"></a><a name="rotateMatrix(Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">rotateMatrix</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function rotateMatrix(angle:Number):void</code><p></p><p></p><p> 根据相应旋转变化得到模型视图矩阵. </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">angle</span>:Number</code></td></tr></table></p></div><a name="scaleMatrix()"></a><a name="scaleMatrix(Number,Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">scaleMatrix</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function scaleMatrix(sx:Number, sy:Number):void</code><p></p><p></p><p> 根据相应缩放变化得到模型视图矩阵. </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sx</span>:Number</code></td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sy</span>:Number</code></td></tr></table></p></div><a name="setBlendFactors()"></a><a name="setBlendFactors(Boolean,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">setBlendFactors</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public static function setBlendFactors(premultipliedAlpha:Boolean, blendMode:String = normal):void</code><p></p><p></p><p> 设置相应混合模式的混合参数. 
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">premultipliedAlpha</span>:Boolean</code> &mdash; 是否预乘透明度
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blendMode</span>:String</code> (default = <code>normal</code>)<code></code> &mdash; 混合模式，默认是normal
		 </td></tr></table></p></div><a name="setDefaultBlendFactors()"></a><a name="setDefaultBlendFactors(Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">setDefaultBlendFactors</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public static function setDefaultBlendFactors(premultipliedAlpha:Boolean):void</code><p></p><p></p><p> 不再使用。调用'setBlendFactors'方法. </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">premultipliedAlpha</span>:Boolean</code></td></tr></table></p></div><a name="setOrthographicProjection()"></a><a name="setOrthographicProjection(Number,Number,Number,Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">setOrthographicProjection</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setOrthographicProjection(x:Number, y:Number, width:Number, height:Number):void</code><p></p><p></p><p> 设置正面二维渲染的矩阵映射. </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:Number</code></td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:Number</code></td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">width</span>:Number</code></td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:Number</code></td></tr></table></p></div><a name="transformMatrix()"></a><a name="transformMatrix(starling.display.DisplayObject)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">transformMatrix</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function transformMatrix(object:<a href="../../starling/display/DisplayObject.html">DisplayObject</a>):void</code><p></p><p></p><p> 根据对象的坐标变换，缩放和旋转生成模型视图矩阵. </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">object</span>:<a href="../../starling/display/DisplayObject.html">DisplayObject</a></code></td></tr></table></p></div><a name="transformMatrixForObject()"></a><a name="transformMatrixForObject(flash.geom.Matrix,starling.display.DisplayObject)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">transformMatrixForObject</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public static function transformMatrixForObject(matrix:Matrix, object:<a href="../../starling/display/DisplayObject.html">DisplayObject</a>):void</code><p></p><p></p><p> 把一个对象的位移，缩放和旋转转化为自定义矩阵. </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">matrix</span>:Matrix</code></td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">object</span>:<a href="../../starling/display/DisplayObject.html">DisplayObject</a></code></td></tr></table></p></div><a name="translateMatrix()"></a><a name="translateMatrix(Number,Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">translateMatrix</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function translateMatrix(dx:Number, dy:Number):void</code><p></p><p></p><p> 根据相应位移变化得到模型视图矩阵. </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">dx</span>:Number</code></td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">dy</span>:Number</code></td></tr></table></p></div><br/><br/><hr><br/><p></p><center class="copyright"><footer>Starling中文站 翻译整理</footer><br/>Sat Jan 19 2013, 02:47 PM +08:00  </center></div></body></html><!--Starling中文站 翻译整理<br/>Sat Jan 19 2013, 02:47 PM +08:00  -->