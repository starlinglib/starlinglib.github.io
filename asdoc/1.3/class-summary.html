<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><!-- saved from url=(0014)about:internet --><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>All Classes</title><link rel="stylesheet" href="style.css" type="text/css" media="screen"><link rel="stylesheet" href="print.css" type="text/css" media="print"><link rel="stylesheet" href="override.css" type="text/css"></head><body><script language="javascript" type="text/javascript" src="asdoc.js"></script><script language="javascript" type="text/javascript" src="help.js"></script><script language="javascript" type="text/javascript" src="cookies.js"></script><script language="javascript" type="text/javascript"><!--
				asdocTitle = 'All Classes - Starling API 1.3 | Starling中文站';
				var baseRef = '';
				window.onload = configPage;
			--></script>
<script type="text/javascript">
			scrollToNameAnchor();
		</script><table class="titleTable" cellpadding="0" cellspacing="0" id="titleTable" style="display:none"><tr><td class="titleTableTitle" align="left">Starling API 1.3 | Starling中文站</td><td class="titleTableTopNav" align="right"><a href="package-summary.html" onclick="loadClassListFrame('all-classes.html')">All Packages</a>&nbsp;|&nbsp;<a href="all-index-A.html" onclick="loadClassListFrame('index-list.html')">Index</a>&nbsp;|&nbsp;<a id="framesLink1" href="index.html?class-summary.html&amp;all-classes.html">Frames</a><a id="noFramesLink1" style="display:none" href="" onclick="parent.location=document.location"> No Frames </a></td><td class="titleTableLogo" align="right" rowspan="3"><img src="images/logo.jpg" class="logoImage" alt=" Adobe Logo " title=" Adobe Logo "></td></tr><tr class="titleTableRow2"><td class="titleTableSubTitle" id="subTitle" align="left">All&nbsp;Classes</td><td class="titleTableSubNav" id="subNav" align="right"></td></tr><tr class="titleTableRow3"><td colspan="3">&nbsp;</td></tr></table><script language="javascript" type="text/javascript" xml:space="preserve">
				<!--
				
					if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle("All Classes"); titleBar_setSubNav(false,false,false,false,false,false,false,false,false,false,false	,false,false,false,false,false);}	
				-->
			</script><div class="MainContent"><br><p>Documentation for classes includes syntax, usage information, and code samples for methods, properties, and event handlers and listeners for those APIs that belong to a specific class in ActionScript. The classes are listed alphabetically. If you are not sure to which class a certain method or property belongs, you can look it up in the Index.</p><br><table cellpadding="3" cellspacing="0" class="summaryTable"><tr><th>&nbsp;</th><th width="20%">Class</th><th width="20%">Package</th><th width="60%">Description</th></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/errors/AbstractClassError.html">AbstractClassError</a><br></td><td class="summaryTableCol"><a href="starling/errors/package-detail.html" onclick="javascript:loadClassListFrame('starling/errors/class-list.html');">starling.errors</a></td><td class="summaryTableLastCol"> 
	 当您尝试创建一个抽象类的一个实例，就会抛出一个AbstractClassError。
	 </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/errors/AbstractMethodError.html">AbstractMethodError</a><br></td><td class="summaryTableCol"><a href="starling/errors/package-detail.html" onclick="javascript:loadClassListFrame('starling/errors/class-list.html');">starling.errors</a></td><td class="summaryTableLastCol"> 当您尝试调用一个抽象方法，就会抛出一个AbstractMethodError。 </td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="com/adobe/utils/AGALMiniAssembler.html">AGALMiniAssembler</a><br></td><td class="summaryTableCol"><a href="com/adobe/utils/package-detail.html" onclick="javascript:loadClassListFrame('com/adobe/utils/class-list.html');">com.adobe.utils</a></td><td class="summaryTableLastCol">
	 AGAL(Adobe Graphics Assembly Language)是Adobe开发的图形汇编语言，汇编语言是仅高于计算机二进制机器码的低级语言，可以精确地操控机器硬件比如可编程显卡，PC的Dirext9、MAC的OpenGL以及移动设备中的OpenGL ES 2都是可编程显卡，并且都支持AGAL。通过Adobe官方提供的编译器AGALMiniAssembler（实际上是一个AS类库），我们可以通过字符串指令来获得一个AGAL二进制流，再通过context3D上传给显卡的编程管线。对于顶点以及片段的运算都是通过AGAL交由显卡来处理的，这就是传说中的GPU硬件加速。
	 </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/utils/AssetManager.html">AssetManager</a><br></td><td class="summaryTableCol"><a href="starling/utils/package-detail.html" onclick="javascript:loadClassListFrame('starling/utils/class-list.html');">starling.utils</a></td><td class="summaryTableLastCol"> AssetManager这个类用于处理加载和访问各种素菜类型。你可以直接添加一个素材（通过'add...'方法），或者通过一个异步队列。
	 这使得你可以用一种统一的方式来处理资源，不管它们是来自于一个外部加载的文件，一个目录，一个URL地址，还是一个嵌入对象。
	 如果你是从磁盘上加载文件，那么下面的类型是支持的：png, jpg, atf, mp3, xml, fnt
     </td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/text/BitmapChar.html">BitmapChar</a><br></td><td class="summaryTableCol"><a href="starling/text/package-detail.html" onclick="javascript:loadClassListFrame('starling/text/class-list.html');">starling.text</a></td><td class="summaryTableLastCol">
	  一个 BitmapChar包含了位图字体的一个字符的相关信息。 在大多数情况下您不需要直接使用这个类。TextField类已经为您做了封装。
	 </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/text/BitmapFont.html">BitmapFont</a><br></td><td class="summaryTableCol"><a href="starling/text/package-detail.html" onclick="javascript:loadClassListFrame('starling/text/class-list.html');">starling.text</a></td><td class="summaryTableLastCol"> 
	  BitmapFont类解析bitmap字体文件，并保存在一个字符表中。
	 
	  这个类解析的XML格式的文件使用了
	  AngelCode Bitmap Font Generator or
	  the Glyph Designer.</td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/display/BlendMode.html">BlendMode</a><br></td><td class="summaryTableCol"><a href="starling/display/package-detail.html" onclick="javascript:loadClassListFrame('starling/display/class-list.html');">starling.display</a></td><td class="summaryTableLastCol"> BlendMode类提供了混合模式视觉效果的常量。
	   
	  一个混合模式，总是由两个'Context3DBlendFactor'值来定义。一个混合因素代表一个特定的四个数值的数组。
	 这个数组是根据源颜色和目标颜色用混合公式计算的，公式如下：
	 
	  result = source × sourceFactor + destination × destinationFactor
	 
	  在这个公式里，源颜色是像素着色器的输出颜色，目标颜色是在上一次清除和绘制操作以后，颜色缓冲区中当前存在的颜色。
	  
	  要注意的是，由于纹理类型的不同，混合因素产生产生的输出也不同。
	 纹理可能包含'预乘透明度'(pma)，意思就是它们的RGB色值是根据它们的颜色值分别相乘得到的（目的是节省计算时间）。
	 基于'BitmapData'的纹理，会含有预乘透明度值，ATF纹理没有这个值。
	 因此，一个混合模式可能会根据pma的值而拥有不同的混合因素。
	  
	  </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/filters/BlurFilter.html">BlurFilter</a><br></td><td class="summaryTableCol"><a href="starling/filters/package-detail.html" onclick="javascript:loadClassListFrame('starling/filters/class-list.html');">starling.filters</a></td><td class="summaryTableLastCol"> BlurFilter用于在一个对象上创建高斯模糊效果。可以分别在x轴和y轴的方向上设置模糊的强度（全局坐标系）。
	  也可以设置为一个阴影或外发光滤镜。使用特定的静态方法来创建特定的滤镜。
     </td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/display/Button.html">Button</a><br></td><td class="summaryTableCol"><a href="starling/display/package-detail.html" onclick="javascript:loadClassListFrame('starling/display/class-list.html');">starling.display</a></td><td class="summaryTableLastCol"> 一个简单的按钮由一张图片和一个可选的文本组成。
	  
	  你可以分别为按钮构造函数传递up和down两种状态的纹理。
	 如果你没有指定一个down状态的纹理，按钮会采用默认的办法：被触碰的时候缩小一点。
	 此外，你可以在按钮上覆盖一个文本，要自定义这个文本，只需要提供和原来的基本相同的文本框即可。
	 你可以使用textBounds属性，将文本移动到一个指定的位置。
	  
	  判断按钮是否被触碰，请使用triggered事件类型，
	 用这个事件来代替普通的触碰事件。也就是说，用户只要在松开手指或者鼠标之前，移动手指/鼠标离开按钮区域，就可以取消对该按钮的点击操作。 
	 </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/utils/Color.html">Color</a><br></td><td class="summaryTableCol"><a href="starling/utils/package-detail.html" onclick="javascript:loadClassListFrame('starling/utils/class-list.html');">starling.utils</a></td><td class="summaryTableLastCol"> 一个非常有用的类，包含在不用颜色表现间转换的预定义颜色和方法.</td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/filters/ColorMatrixFilter.html">ColorMatrixFilter</a><br></td><td class="summaryTableCol"><a href="starling/filters/package-detail.html" onclick="javascript:loadClassListFrame('starling/filters/class-list.html');">starling.filters</a></td><td class="summaryTableLastCol"> ColorMatrixFilter(颜色矩阵滤镜)允许你为输入图片的每个像素的RGBA颜色值和透明度，应用一个4的矩阵变换，来产生一个新的包含RGBA颜色和透明度的数据集。
	  它允许你调整色相变化，饱和度，亮度调整，以及其它各种效果。
      这个类包含了一些用于颜色调整的简便方法。所有这些方法都会改变当前的矩阵，这就意味着你可以很容易的把它们组合在一个滤镜里面:
      
      //用50%的饱和度和180度的色相旋转创建一个翻转滤镜
      var filter:ColorMatrixFilter = new ColorMatrixFilter();
      filter.invert();
      filter.adjustSaturation(-0.5);
      filter.adjustHue(1.0);
	  
      如果你希望让颜色的变化产生动画效果，就在每一步重置滤镜，或者在每一步使用相同的调整值；这个改变就会逐渐累加。
     </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/textures/ConcreteTexture.html">ConcreteTexture</a><br></td><td class="summaryTableCol"><a href="starling/textures/package-detail.html" onclick="javascript:loadClassListFrame('starling/textures/class-list.html');">starling.textures</a></td><td class="summaryTableLastCol"> 一个封装了Stage3D纹理对象的ConcreteTexture，用于存储纹理属性。 </td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/animation/DelayedCall.html">DelayedCall</a><br></td><td class="summaryTableCol"><a href="starling/animation/package-detail.html" onclick="javascript:loadClassListFrame('starling/animation/class-list.html');">starling.animation</a></td><td class="summaryTableLastCol"> DelayedCall类允许你在一定的时间间隔之后去执行某个方法(和setTimeout有些类似)。由于这个类实现了IAnimatable接口，你可以把一个DelayedCall实例添加到juggler中。
	  在大部分情况下，你不需要直接使用这个类；Juggler类包含了一个方法来直接实现延迟调用这个功能。
	  当方法调用完毕之后，DelayedCall对象会派发一个类型是“Event.REMOVE_FROM_JUGGLER”的事件，然后如果不再需要它了，Juggler会自动将它删除。
	  </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/display/DisplayObject.html">DisplayObject</a><br></td><td class="summaryTableCol"><a href="starling/display/package-detail.html" onclick="javascript:loadClassListFrame('starling/display/class-list.html');">starling.display</a></td><td class="summaryTableLastCol">
	  DisplayObject 类是所有可放在显示列表中，在屏幕上可以被渲染的对象的基类。
	  
	  显示列表树 
	  
	  在Starling中，所有可显示对象都处于显示列表树中，只有属于显示列表树的成员才可以在屏幕上显示和渲染。 
	   
	  显示列表树由可以直接渲染到屏幕的叶子节点（Image, Quad）和容器节点（DisplayObjectContainer的子类，比如 Sprite）组成。
	 	   容器是一个包含子节点（子节点可以是叶子节点或者其他容器）的显示对象。 
	  
	  Stage处于显示列表树的顶级节点，同样也是一个容器。
	  要创建一个Starling应用，你需要创建一个自定义的Sprite的子类，Starling会添加一个该子类的实例对象到stage上。
	  
	  一个显示对象有定义它自身相对于它的父级的位置的属性（x，y），有旋转和缩放参数（scaleX，scaleY），
	 可以使用alpha 和 visible属性分别控制显示对象的透明度和可见性。
	  
	  每个显示对象都有可能是触碰事件的目标，你可以设置"touchable"属性来禁止对象被触碰。
	 当它被设置为禁止触碰，对象本身和它的子对象都不会再响应触碰事件。
	    
	  坐标转换
	  
	  在显示坐标树里，每个对象都有自己的局部坐标系统，如果你旋转一个容器，意味着你旋转了整个容器的坐标
	 系统，并且影响到了容器的所有子对象。
	  
	  有时候你需要知道某个点相对于其他坐标系的坐标，getTransformationMatrix函数实现了这个功能。
	 它将创建一个矩阵，该矩阵表示从一个局部坐标系到另一个坐标系的转换。 
	  
	  子类
	  
	  由于DisplayObject是抽象类,所以你不能直接实例化它，只能用某个它的子类。目前已经有很多这样的子类了，
	 大部分情况下它们应该能够满足你的需要了。 
	  
	  然而，你也可以自定义你自己的子类，要实现自定义的子类，你需要实现自定义的渲染方法，在你自定义的子类中
	 需要实现下面的方法：
	  
	  
	    function render(support:RenderSupport, parentAlpha:Number):void
	    function getBounds(targetSpace:DisplayObject, 
	                                 resultRect:Rectangle=null):Rectangle
	  
	  
	  请参阅Quad类，它对于"getBounds"方法有一个简单的实现。
	 一个简单的例子阐述如何创建自定义的渲染方法，你可以参考这个在Starling Wiki上的自定义显示对象 
	 
	  当你重载render方法时，请注意调用辅助对象(一个RenderSupport对象)的'finishQuadBatch'方法。
	 这将促使Starling使用不同的渲染方法来渲染之前累计的所有四边形（鉴于性能考虑），否则，z-ordering将会出错。 
	 
	  </td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/display/DisplayObjectContainer.html">DisplayObjectContainer</a><br></td><td class="summaryTableCol"><a href="starling/display/package-detail.html" onclick="javascript:loadClassListFrame('starling/display/class-list.html');">starling.display</a></td><td class="summaryTableLastCol">
	 一个显示对象容器是一个包含了各种显示对象的集合。
	 这是所有容器类（包含其他显示对象的容器）的基类。它拥有一个有序列表来管理子级对象，并在显示对象树立定义了
	 所有子级的显示顺序。
	  
	  一个容器本身是没有尺寸的，它的宽度和高度代表了子级的范围，改变这些属性会缩放它的所有子级。
	  
	  由于DisplayObjectContainer是一个抽象类，你不能直接实例化它，而是应该使用它的子类。
	 其中最轻量级的容器子类是"Sprite"。
	  
	  添加和删除子级
	  
	  这个类包含了一些允许你添加和删除子级的方法。
	 当你添加一个子级，它会被添加到列表的最顶层，有可能会遮挡住前一个添加的子级。
	 你可以通过索引访问子级，第一个子级索引为0，第二个子级索引为1，以此类推。 
	  
	 向容器添加或者删对象会派发一些不冒泡的事件。
	  
	  
	   Event.ADDED: 对象被添加到了它的父级。
	   Event.ADDED_TO_STAGE: 对象被添加到了它的父级，并且父级已经被添加
	 到stage上，因此对象立即显示。
	   Event.REMOVED: 从对象的父级删除该对象。
	   Event.REMOVED_FROM_STAGE: 从对象的父级删除该对象，并且父级已经被添加
	 到stage上，因此对象立即不显示。
	  
	 
	  
	 尤其是ADDED_TO_STAGE事件是非常有用的，因为它可以让你在一个对象第一次被渲染时自动执行一些逻辑（比如开始播放一段动画）。
	  
	  </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/events/EnterFrameEvent.html">EnterFrameEvent</a><br></td><td class="summaryTableCol"><a href="starling/events/package-detail.html" onclick="javascript:loadClassListFrame('starling/events/class-list.html');">starling.events</a></td><td class="summaryTableLastCol"> 
	  处于显示列表树中的所有显示对象，在每一帧都会派发一个EnterFrameEvent事件。 
	  它包含了从上一帧到现在所经过的时间的信息。这样，您就可以轻松的通过帧频创建动画，传递经过的时间给它。
	 </td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/events/Event.html">Event</a><br></td><td class="summaryTableCol"><a href="starling/events/package-detail.html" onclick="javascript:loadClassListFrame('starling/events/class-list.html');">starling.events</a></td><td class="summaryTableLastCol"> 当事件派发时，事件对象会作为参数传递给事件侦听器。这是Flash Event类的Starling版本。
	 
	  EventDispatcher对象会创建这个类的实例并将它派发到一个已注册的事件侦听器。 
	  一个事件对象包含了作为这个事件特征的信息，其中非常重要的是事件类型，如果事件冒泡的话。
	  事件的目标(target)是派发这个事件的对象。
	 
	  对于某些类型的事件，这些信息就足够了，其他事件可能需要更多的信息来传递给侦听器。 
	  在这种情况下，您可以创建“事件”的子类，并添加您所需要的所有信息作为事件的属性。 
	  “EnterFrameEvent”是这种做法的一个例子，它增加了一个属性用来表示已经执行的时间值。
	 
	  此外，事件类包含的方法可以中断事件的派发，阻止事件被其它的侦听器接受。（ 包括完全阻止
	  或只是阻止进入下一个冒泡阶段）
	 
	  </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/events/EventDispatcher.html">EventDispatcher</a><br></td><td class="summaryTableCol"><a href="starling/events/package-detail.html" onclick="javascript:loadClassListFrame('starling/events/class-list.html');">starling.events</a></td><td class="summaryTableLastCol"> EventDispatcher类是所有具备调度事件能力的类的基类。这是传统Flash里的EventDispatcher在Starling中的对应实现。
	  
	  事件机制也是Starling架构的一个关键特性。通过事件对象可以互相通信。相比传统Flash的事件系统，Starling的事件
	  系统是经过简化的。 主要区别在于，Starling事件没有“捕捉”的阶段。这些事件只是简单的被一个对象派发，并可以选择
	  冒泡。他们不能向相反的方向传递。  
	  就像传统的Flash类那样，显示对象只要继承EventDispatcher就可以派发事件。但要小心， 
	  Starling中的事件不能和传统Flash的事件混用。  Starling的显示对象会派发Starling事件，冒泡也是在Starling
	  显示对象中进行-但是他们不能派发或冒泡传统Flash显示对象的事件。
	  
	  </td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/filters/FragmentFilter.html">FragmentFilter</a><br></td><td class="summaryTableCol"><a href="starling/filters/package-detail.html" onclick="javascript:loadClassListFrame('starling/filters/class-list.html');">starling.filters</a></td><td class="summaryTableLastCol"> FragmentFilter(片段滤镜)类是Starling中所有滤镜效果的基类。这个包中所有的其它滤镜都是扩展自这个类。
	  你可以通过使用属性'filter'，将这些滤镜附加到任何显示对象上。
      一个片段滤镜是通过如下的方式工作的:
      
        应用滤镜的对象会被渲染到一个纹理上 (在全局坐标系下).
        然后这个纹理会被传递给第一个滤镜处理通道。
        每一个通道使用片段着色器(或者额外再加一个顶点着色器)来处理纹理，实现特定的效果。
        每一个通道的输出，将会作为下一个通道的输入。如果它是最终的通道，就会把它直接渲染到后台缓冲区。
      
      所有的这些过程，都被抽象类FragmentFilter定义了。所有的子类只需要覆盖这几个方法：
	  'createPrograms', 'activate' 和 (可选) 'deactivate'，来创建和执行它的自定义着色代码。
	  每一个滤镜可以设置为取代原来的显示对象，或在显示对象的上层或下层绘制。这取决于'mode'属性的设置，可选值定义在'FragmentFilterMode'这个类中。
     	需要注意的是，在同一时刻，每一个滤镜只能应用于一个显示对象。否则，它就会变的很慢，需要更多的资源和缓存，并导致无法预料的后果。
     </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/filters/FragmentFilterMode.html">FragmentFilterMode</a><br></td><td class="summaryTableCol"><a href="starling/filters/package-detail.html" onclick="javascript:loadClassListFrame('starling/filters/class-list.html');">starling.filters</a></td><td class="summaryTableLastCol"> 这个类提供了一些静态变量来表示滤镜模式。
	  这些值用于FragmentFilter.mode属性，并且定义一个滤镜和一个原有对象结合后的呈现结果。</td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/utils/HAlign.html">HAlign</a><br></td><td class="summaryTableCol"><a href="starling/utils/package-detail.html" onclick="javascript:loadClassListFrame('starling/utils/class-list.html');">starling.utils</a></td><td class="summaryTableLastCol"> 提供物件水平方向上的对齐常量值.</td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/animation/IAnimatable.html"><i>IAnimatable</i></a><br></td><td class="summaryTableCol"><a href="starling/animation/package-detail.html" onclick="javascript:loadClassListFrame('starling/animation/class-list.html');">starling.animation</a></td><td class="summaryTableLastCol">  IAnimatable接口定义了这样的一些对象：基于一个时间范围实现动画过程。任何实现了这个接口的类的实例，都可以被添加到juggler。
	   当一个对象不再需要运动的时候，你应当将它从juggler删除。要实现这一点，你可以手动执行这个方法：juggler.remove(object) 来删除它，
	   或者让这个对象派发一个事件来请求juggler删除自己，事件类型是Event.REMOVE_FROM_JUGGLER.</td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/display/Image.html">Image</a><br></td><td class="summaryTableCol"><a href="starling/display/package-detail.html" onclick="javascript:loadClassListFrame('starling/display/class-list.html');">starling.display</a></td><td class="summaryTableLastCol">
	 一个图片是一个映射了纹理的四边形。
	  
	  Image类相当于Flash的Bitmap类的Starling版本，不过Starling是用纹理来代替BitmapData来提供图像的像素资源。
	 要显示一个纹理，你需要把它映射到一个四边形上--这就是Image类的功能。
	  
	  因为"Image"是继承自"Quad",所以你可以给它设置颜色。
	 每个像素的颜色是根据纹理的颜色和四边形的颜色相乘得来的，这样，你就可以很容易的根据一个颜色改变纹理的色调。
	 此外，Image允许你对纹理坐标进行操作，你可以在不改变四边形任何顶点坐标的情况下，在图片的内部移动纹理。
	 你还可以使用这种功能以一个非常高效的方式创建一个矩形遮罩。 
	  
	  </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/animation/Juggler.html">Juggler</a><br></td><td class="summaryTableCol"><a href="starling/animation/package-detail.html" onclick="javascript:loadClassListFrame('starling/animation/class-list.html');">starling.animation</a></td><td class="summaryTableLastCol"> Juggler管理那些实现了IAnimatable接口的对象（比如Tweens）并执行它们。
	 
	  一个juggler实例是一个非常简单的对象。它只是持有一个列表，列表里面是那些实现了IAnimatable接口的对象，并管理它们的执行时间（通过对象自己的advanceTime方法）。当动画播放完毕，就把这个对象抛出。
	  
	  在Starling类中有一个默认的juggler变量:
	  
	  
	  var juggler:Juggler = Starling.juggler;
	  
	  
	  你可以创建你自己的juggler对象，如果需要的话。这样，你就可以组合你的游戏到一些逻辑组件，并独立控制他们的动画。 你需要做的就是，在每一帧都调用你自定义的juggler的advanceTime方法。
	  
	  juggler另一个很强的特性就是"delayCall"方法。使用它可以延迟执行某个方法。但是和传统的延迟调用(比如setTimeout)不同, 这个方法只有在juggler被时间推送器驱动的时候才会起作用，这可以让你更加完美的控制呼叫的逻辑。
	  下面是delayCall的一些示例：
	  
	  juggler.delayCall(object.removeFromParent, 1.0);
	  juggler.delayCall(object.addChild, 2.0, theChild);
	  juggler.delayCall(function():void { doSomethingFunny(); }, 3.0);
	  
	 
	  </td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/events/KeyboardEvent.html">KeyboardEvent</a><br></td><td class="summaryTableCol"><a href="starling/events/package-detail.html" onclick="javascript:loadClassListFrame('starling/events/class-list.html');">starling.events</a></td><td class="summaryTableLastCol"> 一个键盘事件的派发，是对用户使用键盘输入的回应。
	 
	  这个类是Flash的键盘事件的Starling版本。它包含了和Flash的键盘事件相同的属性。 
	 
	  要捕获键盘事件，需要在Starling的stage上添加事件侦听。stage的子节点是不能获取到键盘事件的。 
	  Starling并没有像传统Flash那样的“焦点”的概念。
	  
	  </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/utils/MatrixUtil.html">MatrixUtil</a><br></td><td class="summaryTableCol"><a href="starling/utils/package-detail.html" onclick="javascript:loadClassListFrame('starling/utils/class-list.html');">starling.utils</a></td><td class="summaryTableLastCol"> 一个包含矩阵相关方法的类 </td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/errors/MissingContextError.html">MissingContextError</a><br></td><td class="summaryTableCol"><a href="starling/errors/package-detail.html" onclick="javascript:loadClassListFrame('starling/errors/class-list.html');">starling.errors</a></td><td class="summaryTableLastCol"> 
	 当需要Context3D对象而它不存在或尚未准备好的时候，会抛出一个MissingContextError。
	 </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/display/MovieClip.html">MovieClip</a><br></td><td class="summaryTableCol"><a href="starling/display/package-detail.html" onclick="javascript:loadClassListFrame('starling/display/class-list.html');">starling.display</a></td><td class="summaryTableLastCol"> 一个影片剪辑(MovieClip)根据一个纹理集合来显示动画。
	  
	  传入包含纹理的集合给MovieClip的构造函数作为影片剪辑的帧。影片剪辑会根据第一帧的纹理来确定影片的宽度和高度。
	 如果你使用纹理图集TextureAtlas（推荐使用此方法）来组织你的帧，请使用纹理图集的getTextures方法
	 获取正确(按字母次序的)的纹理顺序。 
	  
	  你可以在构造函数中指定一个特定的帧频，如果需要，你还可以设置每一帧的执行时间，或者在某一帧执行时播放一个声音。
	  
	  play 和 pause 方法可以控制影片的播放，当影片播放完毕时，你会接收到一个Event.MovieCompleted
	 事件。如果影片是循环播放的，这个事件会在每一次循环都派发。
	  
	  同其他动画对象一样，一个影片剪辑必须添加到一个juggler（或者是一个拥有自己的定时执行的advanceTime方法的对象）里来运行。
	 当影片剪辑播放完最后一帧时，会派发"Event.COMPLETE"事件。
	  
	  </td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/display/Quad.html">Quad</a><br></td><td class="summaryTableCol"><a href="starling/display/package-detail.html" onclick="javascript:loadClassListFrame('starling/display/class-list.html');">starling.display</a></td><td class="summaryTableLastCol"> 一个四边形代表了由单一颜色或者渐变颜色填充的矩形。
	  
	  你可以设置每一个顶点的颜色。不同顶点的颜色会在颜色交汇的地方平滑的过度。
	 要让四边形显示一个线性的渐变颜色，需要给顶点0,1设置一个颜色，然后给顶点2,3设置另一个颜色。  
	 
	  四边形的四个顶点的位置是这样排列的:
	  
	  
	  0 - 1
	  | / |
	  2 - 3
	  
	 
	  </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/display/QuadBatch.html">QuadBatch</a><br></td><td class="summaryTableCol"><a href="starling/display/package-detail.html" onclick="javascript:loadClassListFrame('starling/display/class-list.html');">starling.display</a></td><td class="summaryTableLastCol"> 
	 QuadBatch类用于优化渲染大量具备相同状态的四边形(Quad类).</td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/utils/RectangleUtil.html">RectangleUtil</a><br></td><td class="summaryTableCol"><a href="starling/utils/package-detail.html" onclick="javascript:loadClassListFrame('starling/utils/class-list.html');">starling.utils</a></td><td class="summaryTableLastCol"> 一个增强Rectangle类功能的工具类.</td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/core/RenderSupport.html">RenderSupport</a><br></td><td class="summaryTableCol"><a href="starling/core/package-detail.html" onclick="javascript:loadClassListFrame('starling/core/class-list.html');">starling.core</a></td><td class="summaryTableLastCol"> 这个类 包含了简化Stage3D渲染的辅助方法.</td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/textures/RenderTexture.html">RenderTexture</a><br></td><td class="summaryTableCol"><a href="starling/textures/package-detail.html" onclick="javascript:loadClassListFrame('starling/textures/class-list.html');">starling.textures</a></td><td class="summaryTableLastCol"> RenderTexture是一个能在其上绘制任何显示对象的动态纹理。
	 
	  在创建一个RenderTexture对象后，仅需调用 drawObject 方法直接在纹理上渲染一个对象。 
	  对象将会在当前位置，连带当前的旋转，缩放和透明值属性被绘制在纹理上。 
	  
	  绘制能够被高效的完成，因为它在显存中是直接发生的。绘制能够被高效的完成，因为它在显存中是直接发生的。
	  当你在纹理上绘制完对象后，不管你绘制了多少个对象，它的性能将和通常的纹理没什么区别。
	  
	  如果你一次绘制许多的对象的话，推荐通过drawBundled方法把绘制调用捆绑在一个代码块中，像下面展示的一样。
	 那将会产生极大地提速，允许你迅速绘制几百个对象。
	  
	 	
	  renderTexture.drawBundled(function():void
	  {
	     for (var i:int=0; i&lt;numDrawings; ++i)
	     {
	         image.rotation = (2 &#42; Math.PI / numDrawings) &#42; i;
	         renderTexture.draw(image);
	     }   
	  });
	  
	  
	  为了擦除一个经渲染纹理的一部分，你可以使用像“rubber”一样的任意显示对象通过设置它的混合模式为"BlendMode.ERASE"。
	 
	  注意当Starling的渲染上下文丢失，渲染纹理就不能够被恢复。
	  
	 </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/events/ResizeEvent.html">ResizeEvent</a><br></td><td class="summaryTableCol"><a href="starling/events/package-detail.html" onclick="javascript:loadClassListFrame('starling/events/class-list.html');">starling.events</a></td><td class="summaryTableLastCol"> 当Flash容器的尺寸改变后，stage会派发一个ResizeEvent。用这个值可以更新Starling的视口和stage的尺寸。
	  
	  事件的属性包含了更新后的Flash Player的宽度和高度。如果您希望缩放stage上的内容来充满屏幕， 请更新 
	  Starling.current.viewPort 矩形区域。如果您希望使用额外的屏幕区域，
	  请更新 stage.stageWidth 和 stage.stageHeight
	 
	  </td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/utils/ScaleMode.html">ScaleMode</a><br></td><td class="summaryTableCol"><a href="starling/utils/package-detail.html" onclick="javascript:loadClassListFrame('starling/utils/class-list.html');">starling.utils</a></td><td class="summaryTableLastCol"> 用于'RectangleUtil.fit' 方法的缩放模式常量值.</td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/display/Sprite.html">Sprite</a><br></td><td class="summaryTableCol"><a href="starling/display/package-detail.html" onclick="javascript:loadClassListFrame('starling/display/class-list.html');">starling.display</a></td><td class="summaryTableLastCol"> Sprite是一个极其轻量，非抽象的容器类。
	 
	  通常把Sprite作为一种把一组显示对象集中到一个坐标系内的简单手段，也可以把它用做自定义显示对象的基类。
	 
	  "平面化" Sprite对象
	 
	  flatten方法允许你在渲染时优化显示列表中的静态部分。
	 
	  flatten 分析了添加到这个Sprite的显示列表的子对象，优化了渲染调用，极大的提高了渲染速度。
	 但是速度的大幅提升是要付出代价的：你将再也看不见子对象属性的任何变化（位置，旋转，透明等等）。
	 要更新这个sprite对象的显示，只需再一次调用flatten，或者unflatten这个对象。
	 
	  </td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/display/Stage.html">Stage</a><br></td><td class="summaryTableCol"><a href="starling/display/package-detail.html" onclick="javascript:loadClassListFrame('starling/display/class-list.html');">starling.display</a></td><td class="summaryTableLastCol"> Stage是显示列表树的根节点，只有直接或者间接放置到stage上的显示对象才会被渲染。
	 
	  这个类相当于Starling版本的Stage，注意不要和传统的Flash里的Stage混淆。
	  传统的Flash里的Stage只能包含类型为flash.display.DisplayObject的对象，
	  而Starling里的Stage只能包含类型为starling.display.DisplayObject的对象，
	  由于Starling显示列表并不等同于传统Flash显示列表，所以这些类并不兼容，不能混用，也不能互相代替。
	  
	 
	  stage对象是被Starling类自动创建的，请不要手动创建一个stage对象。
	 
	  键盘事件
	 
	  在Starling中，键盘事件只能够在stage派发，所以，如果想捕获到派发的键盘事件，只能给stage添加键盘事件监听。
	 
	  尺寸变化事件
	 
	  当Flash player 尺寸变化时，stage会派发一个ResizeEvent事件。
	  这个事件的属性包含更新后的Flash player的宽度和高度。
	 
	  </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/core/Starling.html">Starling</a><br></td><td class="summaryTableCol"><a href="starling/core/package-detail.html" onclick="javascript:loadClassListFrame('starling/core/class-list.html');">starling.core</a></td><td class="summaryTableLastCol"> Starling类展现了Starling框架的核心.</td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/textures/SubTexture.html">SubTexture</a><br></td><td class="summaryTableCol"><a href="starling/textures/package-detail.html" onclick="javascript:loadClassListFrame('starling/textures/class-list.html');">starling.textures</a></td><td class="summaryTableLastCol"> 一个SubTexture用于表现另一个纹理的一部分。由于这是完全通过操作纹理坐标实现的，使得这个类非常高效。
	  注意：从子纹理继续创建子纹理也是允许的。
	 </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/text/TextField.html">TextField</a><br></td><td class="summaryTableCol"><a href="starling/text/package-detail.html" onclick="javascript:loadClassListFrame('starling/text/class-list.html');">starling.text</a></td><td class="summaryTableLastCol"> TextField类用来显示文本，使用标准的True Type字体或自定义位图字体。
	  
	  您可以设置你用到的所有属性，比如字体名称和字号，颜色，横向和垂直对齐方式，等等。边框属性对于开发是非常有帮助的，因为这样可以让您看到文本的边界。
	  
	  有两种类型的字体可以被显示:
	  
	  
	    标准的true type字体.</td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/textures/Texture.html">Texture</a><br></td><td class="summaryTableCol"><a href="starling/textures/package-detail.html" onclick="javascript:loadClassListFrame('starling/textures/class-list.html');">starling.textures</a></td><td class="summaryTableLastCol">  纹理是用来储存展示图像的信息。它不能直接被添加到显示列表；相应的它必须映射到一个显示对象上。
	  在Staring中那个显示对象就是“Image”类。
	 
	  纹理格式
	  
	  纹理能够由一个“BitmapData”对象创建，Starling能够支持任何Flash所支持的bitmap格式。
	  并且由于你能够将任何Flash显示对象转换为BitmapData对象，你就能够利用这点在Starling中
	  去显示非Starling内容,比如说Shape对象。
	 
	  Starling同时支持ATF纹理（Adobe Texture Format），一个能够通过GPU高效渲染的被压缩纹理的容器。
	  
	  Mip映射
	  
	  MipMaps是按比例缩小的纹理类型。当一个图像被显示时小于它本来的尺寸时，
	  GPU可能就会用mip maps去替代原生纹理。这就可以减少走样和加速渲染。当然这也需要额外的内存开销；
	  你可以权衡利弊之后选择是否使用它。  
	  
	  纹理框架
	  
	  纹理的frame属性允许你设置纹理在image对象中的界限，在纹理周围留有透明空白区域。
	  frame矩形被指定在纹理的坐标系统中，而不是image:
	  
	  
	  var frame:Rectangle = new Rectangle(-10, -10, 30, 30); 
	  var texture:Texture = Texture.fromTexture(anotherTexture, null, frame);
	  var image:Image = new Image(texture);
	  
	  
	  这段代码会创建一个30x30大小的图像，纹理会被放置在图像x=10, y=10 
	  的位置上（假设'anotherTexture'是一个宽高都为10像素的纹理，它将出现在图像的正中位置）。
	  
	  纹理集就采用了这个特性，它允许裁剪一个纹理的透明边缘用来弥补由指定的原始纹理框架改变的尺寸。
	  可以使用TexturePacker这样的工具来优化纹理集。
	 
	  纹理坐标系
	  
	  假如，从另一方面讲，你只想在图像中显示纹理的一部分（就是说修剪这个纹理），
	  你可以创建一个子纹理（通过方法'Texture.fromTexture()'然后指定一个限定范围的矩形），
	  或者你也可以操作image对象的纹理坐标系。方法'image.setTexCoords'允许你那样做。
	 
	  </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/textures/TextureAtlas.html">TextureAtlas</a><br></td><td class="summaryTableCol"><a href="starling/textures/package-detail.html" onclick="javascript:loadClassListFrame('starling/textures/class-list.html');">starling.textures</a></td><td class="summaryTableLastCol"> 纹理集是一个将许多小的纹理整合到一张大图中。这个类是用来从一个纹理集中读取纹理。
	  
	  使用纹理集能为你的纹理解决两个问题:
	  
	  
	    在一定的时间内，始终有一个纹理处于活动的。每当你改变了处于活动的纹理，一个
	        “纹理切换”就会执行，这个切换是需要时间的。
	    任何Stage3D纹理的边长都必须是2的幂数。Starling向你隐藏了这个限制，但这将带来
	        额外的图形存储成本。
	  
	  
	  通过使用纹理集，您可以避免使用纹理切换和取消2的幂数的限制。所有的纹理被集合在一
	     个“超级纹理”，并且Starling会确保纹理正确的部分被显示出来。
	  
	  有几种方法来创建纹理集。一种是使用捆绑在Starling的姊妹框架
	     Sparrow framework。里的纹理集生成脚本。 尽管目前这个脚本只能运行在Mac OS X上。
	     另一个可供选择的出色工具 Texture Packer，
	     他是一个跨平台的商业软件。
	  
	  无论您使用的工具是什么，Starling可以支持以下文档格式:
	 
	  
	 	&lt;TextureAtlas imagePath='atlas.png'&gt;
	 	  &lt;SubTexture name='texture_1' x='0'  y='0' width='50' height='50'/&gt;
	 	  &lt;SubTexture name='texture_2' x='50' y='0' width='20' height='30'/&gt; 
	 	&lt;/TextureAtlas&gt;
	  
	  
	  如果你的图像在边缘具有透明区域，您可以使用Texture类的frame属性。 通过
	     去除纹理的透明边缘并且指定原始尺寸就像这样：
	 
	  
	 	&lt;SubTexture name='trimmed' x='0' y='0' height='10' width='10'
	 	    frameX='-10' frameY='-10' frameWidth='30' frameHeight='30'/&gt;
	  
	 </td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/textures/TextureSmoothing.html">TextureSmoothing</a><br></td><td class="summaryTableCol"><a href="starling/textures/package-detail.html" onclick="javascript:loadClassListFrame('starling/textures/class-list.html');">starling.textures</a></td><td class="summaryTableLastCol"> 这个类为可能的材质平滑算法提供常量值。 </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/events/Touch.html">Touch</a><br></td><td class="summaryTableCol"><a href="starling/events/package-detail.html" onclick="javascript:loadClassListFrame('starling/events/class-list.html');">starling.events</a></td><td class="summaryTableLastCol"> 一个Touch对象包含了在屏幕上的一个手指或鼠标的相关信息（出现或移动）。
	  
	  您将从TouchEvent中获取这个对象。当这样的事件被触发，您可以查询目前呈现在屏幕上的所有触碰。
	  一个Touch对象，包含了一个单指触碰的信息。一个Touch对象总是会通过TouchPhases的集合移动。请参阅TouchPhase类来获取更多信息。
	  
	  触碰的位置
	  
	  您可以用相应的属性，获取坐标系上的当前的和上一个位置。当然，在大部分情况下您希望能获取在一个不同的坐标系上的位置。 
	  基于这个原因，这里有一些方法可以转换当前的和上一个位置到任何对象的局部坐标系。
	 
	  </td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/events/TouchEvent.html">TouchEvent</a><br></td><td class="summaryTableCol"><a href="starling/events/package-detail.html" onclick="javascript:loadClassListFrame('starling/events/class-list.html');">starling.events</a></td><td class="summaryTableLastCol"> 一个TouchEvent是被手指触碰或鼠标输入来触发的。  
	  
	  在Starling中，无论是触碰事件还是鼠标事件，都统一封装为一个类：TouchEvent。
	  要处理用户在一个可触碰的屏幕或使用鼠标完成的输入， 您需要注册一个事件侦听器，来侦听类型是TouchEvent.TOUCH的事件。
	  这是唯一的您需要捕获的事件类型； 原有Flash里面的那个很长的事件类型列表，全都被映射到一个"TouchPhases"里面。 
	 
	  鼠标输入和触摸屏输入的区别是：
	  
	  
	    在某一时刻只有一个鼠标光标可以呈现
	    只有鼠标才可以"hover",即在没有按下按键的情况下滑过一个对象。
	   
	  
	  哪些对象能够接收触碰事件？
	 
	  在Starling中，任何一个显示对象都可以接受触碰事件，只要它的 
	  touchable 属性，以及它的父级都是可用状态(true)。 在Starling中是没有"InteractiveObject"这个类的。
	  
	  如何使用单个触碰对象
	  
	  T事件包含了一个包括所有的触碰对象的列表。每一个独立的触碰都被保存在一个类型是"Touch"的对象里。
	  既然您通常只对在特定对象上发生的触碰感兴趣，您可以查询事件，传入一个具体的目标：
	 
	  var touches:Vector.&lt;Touch&gt; = touchEvent.getTouches(this);
	  
	  这会返回附加在"this"或 它的子级上的所有触碰对象。如果您没有使用多点触碰，您也可以直接访问触碰对象，就像这样：
	 
	  var touch:Touch = touchEvent.getTouch(this);
	  
	  </td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/events/TouchPhase.html">TouchPhase</a><br></td><td class="summaryTableCol"><a href="starling/events/package-detail.html" onclick="javascript:loadClassListFrame('starling/events/class-list.html');">starling.events</a></td><td class="summaryTableLastCol"> 这个类提供了描述触碰的各个阶段的常量值。
	  
	  一个触碰，在它的生命周期内会遵循下面的过程：
	  
	  BEGAN(开始) -> MOVED(移动) -> ENDED(结束)
	  
	  此外，一个触碰可能进入一个称之为STATIONARY(静止)的阶段。这一阶段本身不会触发触碰事件，并且它只能发生在多点触控环境。
	  在某些场合下需要一个解决方案，比如一个手指移动，另一个静止。这个时候，一个触碰事件必须由正在移动的手指下方的对象来派发。
	  在这个事件的触碰对象列表中，您将会找到第二个处于静止状态的触碰对象。
	  
	  最后，还有一个称之为HOVER(悬停)的状态，这种情况只会发生在使用鼠标的情况下。
	  它是由Flash的MouseOver事件触发的，并且这个时候鼠标按键没有被按下。 
	 </td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/animation/Transitions.html">Transitions</a><br></td><td class="summaryTableCol"><a href="starling/animation/package-detail.html" onclick="javascript:loadClassListFrame('starling/animation/class-list.html');">starling.animation</a></td><td class="summaryTableLastCol"> Transitions(过渡)类包含了一些静态方法，来定义缓动相关的函数。这些函数被用在Tween类执行动画的时候。
	 
	  关于transitions这里有一张很直观的图片描述： 
	  
	  
	  你可以使用"registerTransition" 方法来自定义过渡方式.</td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/animation/Tween.html">Tween</a><br></td><td class="summaryTableCol"><a href="starling/animation/package-detail.html" onclick="javascript:loadClassListFrame('starling/animation/class-list.html');">starling.animation</a></td><td class="summaryTableLastCol"> 一个Tween实例，将使用补间动画的方式，"运动"某个对象的属性(比如改变x坐标值，从1,2,3...一直到N，从而形成视觉上的动画效果)。 它可以使用不同的过渡方法，来实现不同的动画方式。
	  
	  这个类的主要用途是实现标准的动画，比如移动，透明度渐变，旋转等等。但是"动画"的范围远远不止于此。只要你想"运动"的对象的属性值是数字 (int, uint, Number), Tween就能搞定它。
	  要了解Tween可以使用的过渡方法的列表，请参阅"Transitions"类。 
	  
	  下面是一个实例，展示了tween移动一个对象到右侧，旋转它，然后让它透明度逐渐降低而消失:
	  
	  
	  var tween:Tween = new Tween(object, 2.0, Transitions.EASE_IN_OUT);
	  tween.animate("x", object.x + 50);
	  tween.animate("rotation", deg2rad(45));
	  tween.fadeTo(0);    // 你也可以使用'animate("alpha", 0)'来代替
	  Starling.juggler.add(tween); 
	   
	  
	  注意在上面的代码的最后，tween的实例被添加到了juggler。这是因为，只有tween自己的"advanceTime"方法被实际执行的时候，tween才会起作用。
	  这个工作juggler会帮你做的，而且它会自动在tween执行完毕的时候删除它。
	  
	  </td></tr><tr class="prow1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/utils/VAlign.html">VAlign</a><br></td><td class="summaryTableCol"><a href="starling/utils/package-detail.html" onclick="javascript:loadClassListFrame('starling/utils/class-list.html');">starling.utils</a></td><td class="summaryTableLastCol"> 提供物件垂直方向上的对齐常量值.</td></tr><tr class="prow0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableSecondCol"><a href="starling/utils/VertexData.html">VertexData</a><br></td><td class="summaryTableCol"><a href="starling/utils/package-detail.html" onclick="javascript:loadClassListFrame('starling/utils/class-list.html');">starling.utils</a></td><td class="summaryTableLastCol"> 
	 顶点数据类，它管理一个顶点信息的原始数据列表，允许直接上传到Stage3D顶点缓冲池中.</td></tr></table><p></p><center class="copyright"><footer>Starling中文站 翻译整理</footer><br/>Sat Jan 19 2013, 02:47 PM +08:00  </center></div></body></html><!--Starling中文站 翻译整理<br/>Sat Jan 19 2013, 02:47 PM +08:00  -->